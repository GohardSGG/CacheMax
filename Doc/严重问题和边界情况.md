
  严重问题和边界情况

  1. 文件被重复修改的情况

  第 0 秒：B.mp 4 开始写入（需要 30 秒）
  第 10 秒：B.mp 4 又被修改（再需要 30 秒）
  第 20 秒：B.mp 4 又被修改（再需要 30 秒）
  问题：会启动 3 个异步任务都在等待同一个文件，没有真正的去重！
  
  Win 32 API 只读锁方案

  核心思路：
  使用 CreateFile API 以 GENERIC_READ 访问权限打开文件，但设置 dwShareMode = FILE_SHARE_READ

  效果：
  - ✅ 我们可以读取文件
  - ✅ 其他程序可以读取文件
  - ❌ 其他程序无法写入文件（会收到"文件正在使用"错误）

  具体参数：
  - DwDesiredAccess: GENERIC_READ
  - DwShareMode: FILE_SHARE_READ （只允许共享读取）
  - DwCreationDisposition: OPEN_EXISTING

  流程：
  1. 文件写入完成
  2. 用 Win 32 API 锁定文件（只读共享模式）
  3. 执行 FastCopy 同步
  4. 关闭句柄释放锁

  优点：
  - 其他程序仍能读取文件（比如文本编辑器能打开查看）
  - 完全阻止写入操作，保证数据一致性
  - 比完全独占锁更用户友好

  缺点：
  - 其他程序尝试保存文件时会失败
  - 需要处理锁定失败的情况

  2. 写入检测可能永远不完成

  文件一直在被其他程序占用写入
  TaskB: 一直等待B.mp 4 写入完成... (永远等待)
  问题：异步任务可能无限期挂起，没有超时机制
  
  那确实可能会有这种情况，他只要一直占用写入，我们就一直不同步，这很正常，等到彻底空了才开始，而且你不能因为他一直写入我们就以后不管他了，他要一直保留在未同步的队列里（哪怕我们软件突然闪退掉关闭掉重新启动，也要保留到这个东西还在队列里）

  3. 内存泄漏风险

  大量文件快速变化 → 启动大量异步任务 → 都在等待写入完成
  问题：可能同时有几百个异步任务在等待，消耗大量内存

这个无所谓，我的机器有大量的内存
只要确保最后能回收干净就行

  4. 文件删除的边界情况

  第 0 秒：检测到文件创建，启动任务
  第 5 秒：文件被删除
  第 10 秒：任务完成写入检测，准备同步一个不存在的文件
  
  同问题 1 方案解决

  5. FastCopy 进程异常退出

  3 个 FastCopy 进程都在运行
  其中一个异常退出，但我们的许可计数器没更新
  问题：许可计数器和实际进程数不同步

如果异常退出，我们应该要有捕获的机制，并且有能更新同步的机制，这是非常基础的

  6. 磁盘空间不足

  大文件同步到一半，目标磁盘空间不足
  FastCopy 失败，但源文件继续被修改

这种情况属于目标硬盘空间不够，只需要提示我们并且弹出警告以保留我们后来手动处理的机会就好

  7. 同名文件覆盖竞争

  A 文件夹下的 test. Txt 和 B 文件夹下的 test. Txt 同时变化
  都要同步到同一个目标位置

完全不可能有同名文件呀，因为他们要同步到各自的 a 文件夹和 b 文件夹，怎么可能会有重名呢




  你觉得这些边界情况中，哪些是我们必须要解决的？哪些可以接受？


     1. 文件级去重优化 - 在事件检测阶段

     - 将去重机制提前到文件变化事件时
     - 使用ConcurrentDictionary追踪每个文件的处理任务     
     - 新事件到来时取消旧任务，只保留最新的

     2. Win32 API文件锁定机制

     - 在SafeFileOperations中添加独占读锁方法
     - 使用CreateFile API，设置FILE_SHARE_READ（只允许读）
     - 在文件写入完成后立即锁定，同步完成后释放

     3. FastCopy进程监控和错误恢复

     - 监控Process.HasExited属性
     - 捕获进程异常退出事件
     - 自动释放Semaphore许可，保持计数器同步

     4. FastCopy错误捕获和通知

     - 解析FastCopy的ExitCode
     - 捕获标准错误输出
     - 磁盘空间不足等错误时显示UI通知

     5. Semaphore计数器同步修复

     - 使用try-finally确保许可释放
     - 定期校验实际进程数与计数器
     - 异常情况下的自动恢复机制

     6. 移除复杂的优先级和批处理逻辑

     - 删除FileOperationAnalyzer类
     - 移除SyncPriority枚举
     - 简化为直接同步模式
     - 删除批处理定时器

     实施顺序：

     1. 先简化代码（移除复杂逻辑）
     2. 实现文件锁定机制
     3. 优化去重逻辑
     4. 加强错误处理
     5. 测试验证

     这样可以确保：
     - 100%数据一致性
     - 避免重复处理
     - 优雅处理异常情况
     - 代码更简洁可维护
