# 4. 统一开发流程

> **文档版本**: 3.0
> **更新日期**: 2025-11-08
> **文档说明**: 本文档描述CacheMax的统一开发流程和核心业务流程

---

## 目录

- [4.1 开发环境搭建](#41-开发环境搭建)
- [4.2 核心业务流程](#42-核心业务流程)
  - [4.2.1 加速初始化流程](#421-加速初始化流程)
  - [4.2.2 文件同步流程](#422-文件同步流程)
  - [4.2.3 停止加速流程](#423-停止加速流程)
  - [4.2.4 应用启动恢复流程](#424-应用启动恢复流程)
- [4.3 代码提交流程](#43-代码提交流程)
- [4.4 发布流程](#44-发布流程)

---

## 4.1 开发环境搭建

### 必需软件

| 软件 | 版本 | 下载地址 | 用途 |
|------|------|----------|------|
| **Visual Studio** | 2022+ | [官网](https://visualstudio.microsoft.com/) | C# IDE |
| **.NET SDK** | 8.0+ | [官网](https://dotnet.microsoft.com/) | 编译运行 |
| **FastCopy** | 最新版 | [官网](https://fastcopy.jp/) | 测试文件复制 |
| **Git** | 最新版 | [官网](https://git-scm.com/) | 版本控制 |

### Visual Studio工作负载

```
必需工作负载:
- .NET桌面开发
- 通用Windows平台开发 (可选，用于UWP相关)

可选组件:
- C# and Visual Basic Roslyn compilers
- .NET Profiling tools
- Live Unit Testing
```

### 项目结构

```
CacheMax/
├─ CacheMax.GUI/          # WPF主项目
│  ├─ Services/           # 服务层
│  ├─ ViewModels/         # 视图模型
│  ├─ Views/              # XAML视图
│  ├─ MainWindow.xaml     # 主窗口
│  └─ App.xaml            # 应用程序入口
├─ Doc/                   # 文档
│  └─ Main/               # 主文档目录
└─ README.md              # 项目说明
```

### 首次运行步骤

```bash
# 1. 克隆项目
git clone https://github.com/yourname/CacheMax.git
cd CacheMax

# 2. 还原依赖
dotnet restore

# 3. 编译项目
dotnet build

# 4. 运行项目 (Debug模式)
dotnet run --project CacheMax.GUI

# 或者在Visual Studio中按F5
```

---

## 4.2 核心业务流程

### 4.2.1 加速初始化流程

**触发**: 用户点击"添加文件夹"按钮

#### 流程图

```
┌─────────────────────────────────────────┐
│  Step 1: 用户选择源目录和缓存根目录      │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 2: 验证路径有效性                 │
│  - 源目录存在                           │
│  - 不在禁止列表 (C:\Windows等)          │
│  - 缓存根目录可写                       │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 3: 调用CacheManagerService        │
│  InitializeCacheAcceleration()          │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 4: Robocopy批量复制               │
│  robocopy "源" "缓存"                   │
│    /MIR /MT:64 /J /R:3600               │
│  UI显示进度条 (0-80%)                   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 5: 重命名原始目录                 │
│  Directory.Move(                        │
│    "D:\MyProject",                      │
│    "D:\MyProject.original"              │
│  )                                      │
│  File.SetAttributes(Hidden)             │
│  UI显示进度 (80-85%)                    │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 6: 创建Junction                   │
│  JunctionService.CreateDirectoryJunction│
│  mklink /J                              │
│    "D:\MyProject"                       │
│    "S:\Cache\D\MyProject"               │
│  UI显示进度 (85-95%)                    │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 7: 启动文件监控                   │
│  FileSyncService.StartMonitoring()      │
│  FileSystemWatcher开始监控缓存目录      │
│  UI显示进度 (95-100%)                   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Step 8: 更新配置和UI                   │
│  ConfigService.AddAcceleratedFolder()   │
│  UI状态变为"已加速"                     │
│  触发AccelerationCompleted事件          │
└─────────────────────────────────────────┘
```

#### 代码示例

```csharp
public async Task InitializeCacheAcceleration(string folder, string cacheRoot)
{
    try
    {
        StatusChanged?.Invoke(this, "初始化中", 0);

        // Step 1: 构建路径
        var cachePath = BuildCachePath(folder, cacheRoot);
        var originalPath = folder + ".original";

        // Step 2: Robocopy批量复制 (0-80%)
        await RobocopyHelper.CopyDirectoryAsync(
            folder,
            cachePath,
            progress => StatusChanged?.Invoke(this, "复制中", progress * 0.8)
        );

        // Step 3: 重命名原始目录 (80-85%)
        StatusChanged?.Invoke(this, "重命名中", 80);
        Directory.Move(folder, originalPath);
        File.SetAttributes(originalPath, FileAttributes.Hidden);

        // Step 4: 创建Junction (85-95%)
        StatusChanged?.Invoke(this, "创建连接点", 85);
        var (success, error) = await _junctionService.CreateDirectoryJunction(
            folder,
            cachePath
        );

        if (!success)
            throw new Exception($"Junction创建失败: {error}");

        // Step 5: 启动监控 (95-100%)
        StatusChanged?.Invoke(this, "启动监控", 95);
        await _fileSyncService.StartMonitoring(cachePath, originalPath);

        // Step 6: 保存配置
        _configService.AddAcceleratedFolder(new AcceleratedFolder
        {
            OriginalPath = originalPath,
            CachePath = cachePath,
            MountPoint = folder,
            CreatedAt = DateTime.Now,
            Status = "已加速"
        });

        StatusChanged?.Invoke(this, "已加速", 100);
        AccelerationCompleted?.Invoke(this, folder);
    }
    catch (Exception ex)
    {
        AccelerationFailed?.Invoke(this, folder, ex.Message);
        throw;
    }
}
```

---

### 4.2.2 文件同步流程

**触发**: 用户修改缓存中的文件 → FileSystemWatcher检测到变化

#### 流程图

```
┌─────────────────────────────────────────┐
│  用户修改文件 (访问D:\MyProject)         │
│  实际写入: S:\Cache\D\MyProject          │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  FileSystemWatcher.Changed事件          │
│  - Created / Changed / Deleted / Renamed│
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  FileSyncService.OnFileChanged()        │
│  检查去重窗口 (500ms)                    │
└─────────────────────────────────────────┘
              ↓ (如果不是重复事件)
┌─────────────────────────────────────────┐
│  创建SyncOperation                      │
│  {                                      │
│    Source: S:\Cache\D\MyProject\file.txt│
│    Dest: D:\MyProject.original\file.txt │
│    Type: Changed                        │
│  }                                      │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  加入ConcurrentQueue                    │
│  发送UIUpdateMessage (QueueItemAdded)   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  等待Timer触发ProcessQueueAsync()       │
│  - 智能同步Timer (10s)                  │
│  - 定期同步Timer (30s)                  │
│  - 或立即处理 (高优先级)                │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  SemaphoreSlim.WaitAsync()              │
│  等待可用的并发槽位 (最多3个)           │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  SafeFileOperations.IsFileInUse()       │
│  检查文件是否被锁定                     │
└─────────────────────────────────────────┘
       ↓ Yes          ↓ No
  [跳过，稍后重试]    [继续]
              ↓
┌─────────────────────────────────────────┐
│  FastCopyService.CopyFileAsync()        │
│  fcp.exe /cmd=diff                      │
│    "缓存文件" /to="原始.original文件"   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  等待FastCopy完成 (最多30分钟)           │
│  进程监控Timer检查超时                  │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  发送UIUpdateMessage                    │
│  (QueueItemUpdated / Completed / Failed)│
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  UI更新队列状态                         │
│  进行中 → 已完成 / 失败                 │
│  更新统计信息                           │
└─────────────────────────────────────────┘
```

#### 代码示例

```csharp
// FileSystemWatcher事件处理
private void OnFileChanged(object sender, FileSystemEventArgs e)
{
    // 去重检查
    if (_lastEventTime.TryGetValue(e.FullPath, out var lastTime))
    {
        if ((DateTime.Now - lastTime).TotalMilliseconds < 500)
            return;
    }

    _lastEventTime[e.FullPath] = DateTime.Now;

    // 创建同步操作
    var operation = new SyncOperation
    {
        Source = e.FullPath,
        Destination = MapToOriginalPath(e.FullPath),
        Type = e.ChangeType,
        QueuedAt = DateTime.Now
    };

    // 加入队列
    _syncQueue.Enqueue(operation);

    // 通知UI
    _ = _uiChannel.Writer.WriteAsync(new UIUpdateMessage
    {
        Type = UIUpdateType.QueueItemAdded,
        Item = CreateQueueItem(operation)
    });
}

// 处理队列
private async Task ProcessQueueAsync()
{
    while (_syncQueue.TryDequeue(out var operation))
    {
        await _semaphore.WaitAsync();

        _ = Task.Run(async () =>
        {
            try
            {
                // 检查文件锁
                if (SafeFileOperations.IsFileInUse(operation.Source))
                {
                    _syncQueue.Enqueue(operation); // 重新入队
                    return;
                }

                // 执行复制
                var (success, output) = await FastCopyService.Instance
                    .CopyFileAsync(operation.Source, operation.Destination);

                // 更新UI
                await _uiChannel.Writer.WriteAsync(new UIUpdateMessage
                {
                    Type = success ?
                        UIUpdateType.QueueItemCompleted :
                        UIUpdateType.QueueItemFailed,
                    Item = operation,
                    Message = output
                });

                // 触发事件
                if (success)
                    SyncCompleted?.Invoke(this, operation);
                else
                    SyncFailed?.Invoke(this, operation, output);
            }
            finally
            {
                _semaphore.Release();
            }
        });
    }
}
```

---

### 4.2.3 停止加速流程

**触发**: 用户点击"停止加速"按钮

#### 流程图

```
用户选择DataGrid中的行
    ↓
点击"停止加速"按钮
    ↓
MessageBox确认
"是否删除缓存?"
    ↓ Yes / No
CacheManagerService.StopCacheAcceleration(mountPoint, deleteCache)
    ↓
停止FileSyncService监控
FileSystemWatcher.Dispose()
    ↓
等待同步队列清空
(如果有正在进行的操作)
    ↓
删除Junction
JunctionService.RemoveJunction()
    ↓
可选: 删除缓存目录
if (deleteCache)
    Directory.Delete(cachePath, recursive: true)
    ↓
重命名.original回原名称
Directory.Move(
    "D:\MyProject.original",
    "D:\MyProject"
)
    ↓
从配置中移除
ConfigService.RemoveAcceleratedFolder()
    ↓
从UI中移除
ObservableCollection.Remove()
```

---

### 4.2.4 应用启动恢复流程

**触发**: 应用程序启动

#### 流程图

```
App.xaml.cs OnStartup()
    ↓
CacheManagerService.RestoreAccelerationStates()
    ↓
从accelerated_folders.json读取所有配置
    ↓
对每个AcceleratedFolder:
┌──────────────────────────────────┐
│ 1. 检查Junction是否存在          │
│    JunctionService.IsJunction()  │
└──────────────────────────────────┘
    ↓ Yes               ↓ No
[检查目标]         [标记为"失败"]
    ↓
┌──────────────────────────────────┐
│ 2. 检查Junction目标是否正确      │
│    GetJunctionTarget() ==        │
│    CachePath?                    │
└──────────────────────────────────┘
    ↓ Yes               ↓ No
[检查目录]     [标记为"Junction异常"]
    ↓
┌──────────────────────────────────┐
│ 3. 检查缓存和.original目录存在   │
│    Directory.Exists(CachePath)   │
│    Directory.Exists(OriginalPath)│
└──────────────────────────────────┘
    ↓ Yes               ↓ No
[重启监控]       [标记为"目录丢失"]
    ↓
FileSyncService.StartMonitoring()
    ↓
标记为"已加速"
    ↓
更新UI显示
```

---

## 4.3 代码提交流程

### Git工作流

```bash
# 1. 创建功能分支
git checkout -b feature/your-feature-name

# 2. 开发并提交
git add .
git commit -m "feat: add new feature description"

# 3. 推送到远程
git push origin feature/your-feature-name

# 4. 创建Pull Request
# 在GitHub/GitLab上创建PR

# 5. Code Review通过后合并到main
```

### Commit消息规范

```
类型(范围): 简短描述

详细描述 (可选)

类型:
- feat: 新功能
- fix: 修复bug
- docs: 文档更新
- style: 代码格式调整
- refactor: 重构代码
- test: 添加测试
- chore: 构建/工具变动

示例:
feat(FileSyncService): 添加智能同步Timer
fix(JunctionService): 修复Junction创建失败的bug
docs(README): 更新安装说明
```

---

## 4.4 发布流程

### 编译Release版本

```bash
# 1. 清理
dotnet clean

# 2. 发布Release版本
dotnet publish -c Release -r win-x64 --self-contained false

# 输出目录: bin\Release\net8.0-windows\win-x64\publish\
```

### 发布清单

```
发布包应包含:
✅ CacheMax.GUI.exe
✅ 所有.dll依赖
✅ appsettings.json
✅ README.md
✅ LICENSE

不应包含:
❌ accelerated_folders.json (用户配置)
❌ Logs\ (用户日志)
❌ .pdb调试符号
```

---

## 相关文档

- **[2.技术架构总览](./2.技术架构总览.md)** - 了解系统架构
- **[5.功能模块设计](./5.功能模块设计.md)** - 了解各模块详细实现
- **[7.技术风险与解决方案](./7.技术风险与解决方案.md)** - 故障排查

---

**文档结束** | [返回文档目录](./README.md)
