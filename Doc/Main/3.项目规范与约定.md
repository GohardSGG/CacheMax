# 3. 项目规范与约定

> **文档版本**: 3.1
> **更新日期**: 2025-11-08
> **文档说明**: 本文档描述CacheMax项目的开发规范、约定和最佳实践

---

## 目录

- [3.1 权限要求](#31-权限要求)
- [3.2 数据安全规范](#32-数据安全规范)
- [3.3 文件命名约定](#33-文件命名约定)
- [3.4 代码规范](#34-代码规范)
- [3.5 配置文件规范](#35-配置文件规范)

---

## 3.1 权限要求

### 无需管理员权限

CacheMax设计为**普通用户权限**即可运行的应用，关键原因：

1. **目录Junction创建**: 使用`mklink /J`而非`mklink /D`（符号链接需要管理员）
2. **用户空间运行**: 所有操作在用户目录和用户指定目录
3. **无系统文件修改**: 不修改注册表、系统服务等

### 必需权限

| 权限类型 | 说明 | 用途 |
|---------|------|------|
| **读取权限** | 源目录及其所有文件 | 初始复制、监控变化 |
| **写入权限** | 缓存目录及其父目录 | 创建缓存、写入文件 |
| **删除权限** | Junction点、`.original`目录 | 停止加速时清理 |
| **执行权限** | 可执行文件目录 | 读写配置、日志文件 |

### 文件权限保持

```csharp
// Robocopy复制时保留ACL
/COPY:DATSOU
D - Data
A - Attributes
T - Timestamps
S - Security (NTFS ACLs)
O - Owner
U - Auditing info

// Junction重定向时不改变权限
// 访问权限由目标目录决定
```

---

## 3.2 数据安全规范

### 数据完整性保证

#### 1. 批量复制策略

```bash
# 初始复制使用Robocopy镜像模式
robocopy "源目录" "缓存目录" /MIR /MT:64 /J /R:3600
```

- `/MIR`: 镜像模式，完整复制目录树
- `/MT:64`: 64线程并行，加速复制
- `/J`: 无缓冲I/O，适合大文件
- `/R:3600`: 失败时最多重试3600次

#### 2. 增量同步策略

```bash
# 增量同步使用FastCopy差异模式
fcp.exe /cmd=diff /auto_close "源文件" /to="目标文件"
```

- `/cmd=diff`: 差异复制，只复制变化的文件
- `/auto_close`: 完成后自动关闭

#### 3. 原始数据备份

```
原始数据保留在 .original 目录:
D:\MyProject.original (隐藏属性)

即使缓存损坏，原始数据始终安全
```

### 隐私安全

#### 不收集用户数据

- ❌ 无网络请求
- ❌ 无数据上传
- ❌ 无用户追踪

#### 本地存储

```
所有数据存储在本地:
- 配置文件: accelerated_folders.json
- 日志文件: Logs\CacheMax_*.log
- 缓存数据: 用户指定的缓存根目录
```

#### 日志内容

```
日志仅包含操作记录:
✅ 文件路径
✅ 操作类型 (创建/修改/删除)
✅ 时间戳
✅ 错误信息

❌ 不包含文件内容
❌ 不包含用户个人信息
```

### 潜在风险

| 风险 | 严重性 | 缓解措施 |
|------|--------|----------|
| **缓存与原始目录不一致** | 高 | 实时同步 + 定期同步双保险 |
| **Junction误删** | 中 | 健康检查 + 自动恢复 |
| **同步失败导致数据丢失** | 中 | .original目录始终保留最新备份 |
| **停止加速时选择删除缓存** | 低 | 二次确认弹窗 |

---

## 3.3 文件命名约定

### 配置文件

```
accelerated_folders.json    - 主配置文件
appsettings.json           - 工具配置（FastCopy/Robocopy）
```

### 日志文件

```
格式: CacheMax_{timestamp}.log
示例: CacheMax_20251108_143015.log

滚动策略:
- 单文件最大 50MB
- 最多保留 5个文件
```

### 缓存目录结构

```
缓存根目录 (如 S:\Cache)
├─ C\                      # C盘缓存
│  ├─ Users\
│  │  └─ Username\
│  │     └─ Desktop\
│  └─ ...
├─ D\                      # D盘缓存
│  └─ MyProject\
└─ ...

镜像源驱动器结构，便于管理
```

### .original目录

```
原始目录:      D:\MyProject
Junction:      D:\MyProject  → S:\Cache\D\MyProject
备份目录:      D:\MyProject.original (隐藏)

命名规则: {原始路径}.original
文件属性: Hidden
```

---

## 3.4 代码规范

### C#编码规范

#### 1. 命名规范

```csharp
// PascalCase: 类名、方法名、属性名
public class CacheManagerService { }
public async Task InitializeCacheAcceleration() { }
public string MountPoint { get; set; }

// camelCase: 局部变量、参数
var cacheRoot = "S:\\Cache";
public void ProcessQueue(string filePath) { }

// _camelCase: 私有字段
private readonly Channel<UIUpdateMessage> _uiChannel;
private SemaphoreSlim _semaphore;

// UPPER_CASE: 常量
private const int MAX_RETRY_COUNT = 5;
private const string DEFAULT_CACHE_ROOT = "S:\\Cache";
```

#### 2. 异步规范

```csharp
// 所有I/O操作必须异步
public async Task<bool> CopyFileAsync(string source, string dest)
{
    await using var sourceStream = File.OpenRead(source);
    await using var destStream = File.Create(dest);
    await sourceStream.CopyToAsync(destStream);
    return true;
}

// async方法命名必须以Async结尾
public async Task ProcessQueueAsync() { }

// 避免async void (除非事件处理器)
public async void Button_Click(object sender, EventArgs e) { } // OK
public async void DoWork() { } // 不OK
```

#### 3. Nullable引用类型

```csharp
// 启用nullable
#nullable enable

// 参数可空时明确标注
public string? GetJunctionTarget(string junctionPath)
{
    // 可能返回null
}

// 非空断言
var target = GetJunctionTarget(path)!; // 确定不为null时使用
```

#### 4. 资源释放

```csharp
// 使用using确保释放
using var watcher = new FileSystemWatcher(path);
await using var stream = File.OpenRead(file);

// 实现IDisposable
public class FileSyncService : IDisposable
{
    private readonly FileSystemWatcher _watcher;

    public void Dispose()
    {
        _watcher?.Dispose();
        GC.SuppressFinalize(this);
    }
}
```

### XAML编码规范

#### 1. 数据绑定

```xaml
<!-- 使用Binding而非x:Bind (WPF不支持) -->
<TextBlock Text="{Binding Path=Status}" />

<!-- 指定UpdateSourceTrigger -->
<TextBox Text="{Binding Path=MountPoint, UpdateSourceTrigger=PropertyChanged}" />

<!-- 使用DataTrigger条件样式 -->
<DataTrigger Binding="{Binding Status}" Value="已加速">
    <Setter Property="Foreground" Value="Green" />
</DataTrigger>
```

#### 2. 资源定义

```xaml
<!-- 在App.xaml中定义全局样式 -->
<Application.Resources>
    <SolidColorBrush x:Key="SuccessColor" Color="#4CAF50" />
    <SolidColorBrush x:Key="ErrorColor" Color="#F44336" />
</Application.Resources>
```

#### 3. INotifyPropertyChanged实现规范

**重要教训**: WPF数据绑定必须配合PropertyChanged通知，否则UI不会更新

##### 错误示例

```csharp
// ❌ 简单自动属性 - UI不会更新
public class AcceleratedFolder
{
    public long CacheSize { get; set; }
    public string OriginalPath { get; set; }
    public string CachePath { get; set; }
}

// 问题: 当代码执行 folder.CacheSize = newValue 时
//       值虽然改变了，但WPF绑定系统不知道
//       导致UI显示仍是旧值
```

##### 正确示例

```csharp
// ✅ 带通知的属性 - UI自动更新
public class AcceleratedFolder : INotifyPropertyChanged
{
    private long _cacheSize = 0;
    public long CacheSize
    {
        get => _cacheSize;
        set
        {
            _cacheSize = value;
            OnPropertyChanged(nameof(CacheSize));
            OnPropertyChanged(nameof(CacheSizeFormatted));  // 同时通知依赖属性
        }
    }

    private string _originalPath = string.Empty;
    public string OriginalPath
    {
        get => _originalPath;
        set
        {
            _originalPath = value;
            OnPropertyChanged(nameof(OriginalPath));
        }
    }

    // 实现INotifyPropertyChanged接口
    public event PropertyChangedEventHandler? PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

##### 规范要点

**1. 适用场景**

必须使用PropertyChanged通知的情况：
- ✅ 所有需要绑定到UI的属性
- ✅ 计算属性的依赖项
- ✅ ObservableCollection中的对象属性

不需要通知的情况：
- ❌ 仅用于内部逻辑的私有字段
- ❌ 常量和只读属性
- ❌ 方法参数和局部变量

**2. 依赖属性通知**

```csharp
// CacheSizeFormatted依赖于CacheSize
public long CacheSize
{
    get => _cacheSize;
    set
    {
        _cacheSize = value;
        OnPropertyChanged(nameof(CacheSize));           // 通知自己
        OnPropertyChanged(nameof(CacheSizeFormatted));  // 通知依赖者
    }
}

[JsonIgnore]
public string CacheSizeFormatted => FormatBytes(CacheSize);
```

**3. 命名约定**

```csharp
// 使用nameof避免字符串拼写错误
OnPropertyChanged(nameof(CacheSize));      // ✅ 推荐
OnPropertyChanged("CacheSize");            // ⚠️ 易出错
OnPropertyChanged("cachSize");             // ❌ 拼写错误，难以发现
```

**4. 常见错误**

| 错误类型 | 症状 | 解决方法 |
|---------|------|----------|
| **忘记调用OnPropertyChanged** | 值改变但UI不更新 | 在setter中添加通知调用 |
| **属性名拼写错误** | UI不更新且无报错 | 使用nameof(PropertyName) |
| **忘记通知依赖属性** | 计算属性不更新 | 通知所有依赖此属性的属性 |
| **循环通知** | StackOverflowException | 检查属性间依赖关系 |

**5. 调试技巧**

```csharp
// 添加日志确认通知被触发
protected virtual void OnPropertyChanged(string propertyName)
{
    #if DEBUG
    System.Diagnostics.Debug.WriteLine($"PropertyChanged: {propertyName}");
    #endif

    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}
```

##### 实际案例：缓存大小不更新

**问题**: 日志显示"缓存大小已更新"，但UI表格仍显示"0 B"

**原因分析**:
```csharp
// 原代码（错误）
public long CacheSize { get; set; }

// 虽然 folder.CacheSize = newSize 执行了
// 但WPF绑定系统没有收到通知
```

**修复方案**:
```csharp
// 修复后
private long _cacheSize = 0;
public long CacheSize
{
    get => _cacheSize;
    set
    {
        _cacheSize = value;
        OnPropertyChanged(nameof(CacheSize));
        OnPropertyChanged(nameof(CacheSizeFormatted));
    }
}
```

**结果**: UI立即显示正确的缓存大小

---

## 3.5 配置文件规范

### appsettings.json

```json
{
  "FastCopy": {
    "ExecutablePath": "C:\\Program Files\\FastCopy64\\fcp.exe",
    "DefaultArguments": "/cmd=diff /auto_close /force_close",
    "MaxConcurrency": 3,
    "TimeoutMinutes": 30
  },
  "Robocopy": {
    "ThreadCount": 64,
    "RetryCount": 3600,
    "RetryWaitSeconds": 1,
    "EnableUnbufferedIO": true,
    "ShowProgress": true,
    "ShowETA": true
  },
  "ForbiddenDirectories": [
    "C:\\Windows",
    "C:\\Program Files",
    "C:\\Program Files (x86)",
    "C:\\ProgramData",
    "C:\\$Recycle.Bin"
  ],
  "Logging": {
    "LogDirectory": "Logs",
    "MaxLogFileSize": 52428800,
    "MaxLogFiles": 5,
    "LogLevels": ["Info", "Warning", "Error"]
  }
}
```

### accelerated_folders.json

```json
{
  "DefaultCacheRoot": "S:\\Cache",
  "AcceleratedFolders": [
    {
      "OriginalPath": "D:\\MyProject",
      "CachePath": "S:\\Cache\\D\\MyProject",
      "MountPoint": "D:\\MyProject",
      "CreatedAt": "2025-11-08T10:30:00",
      "Status": "已加速",
      "ProgressPercentage": 100,
      "CacheSize": 1073741824
    }
  ],
  "AutoStartWithWindows": false,
  "MinimizeToTray": true
}
```

### 配置修改规范

1. **手动编辑**: 确保JSON格式正确
2. **备份**: 修改前备份原文件
3. **验证**: 重启应用验证配置有效

---

## 相关文档

- **[2.技术架构总览](./2.技术架构总览.md)** - 了解系统架构和核心组件
- **[4.统一开发流程](./4.统一开发流程.md)** - 了解开发工作流程
- **[9.安全与权限](./7.技术风险与解决方案.md#91-权限要求)** - 详细的安全说明

---

**文档结束** | [返回文档目录](./README.md)
