# 2. 技术架构总览

> **文档版本**: 3.0
> **更新日期**: 2025-11-08
> **文档说明**: 本文档描述CacheMax的整体架构设计、核心组件和数据流向

---

## 目录

- [2.1 总体架构](#21-总体架构)
  - [2.1.1 数据流向](#211-数据流向)
- [2.2 核心组件详解](#22-核心组件详解)
  - [2.2.1 CacheManagerService](#221-cachemanagerservice)
  - [2.2.2 FileSyncService](#222-filesyncservice)
  - [2.2.3 JunctionService](#223-junctionservice)
  - [2.2.4 FastCopyService](#224-fastcopyservice)
  - [2.2.5 ErrorRecoveryService](#225-errorrecoveryservice)
  - [2.2.6 ConfigService](#226-configservice)
  - [2.2.7 AsyncLogger](#227-asynclogger)
  - [2.2.8 SafeFileOperations](#228-safefileoperations)
  - [2.2.9 SingleInstanceManager](#229-singleinstancemanager)

---

## 2.1 总体架构

CacheMax采用**分层架构设计**，从上到下分为4层：用户界面层、核心服务层、外部工具层、Windows文件系统层。

### 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                     用户界面层 (WPF)                             │
│                                                                  │
│  MainWindow.xaml.cs                                             │
│  ├─ DataGrid (加速文件夹列表, 7列)                              │
│  ├─ TabControl (同步队列: 进行中/已完成)                        │
│  ├─ StatusBar (实时统计: 队列数/成功数/失败数)                  │
│  ├─ TextBox (输出日志, 150行容量)                               │
│  └─ NotifyIcon (系统托盘)                                       │
│                                                                  │
│  ObservableCollection绑定, INotifyPropertyChanged              │
└─────────────────────────────────────────────────────────────────┘
                            ↕
              Channel<UIUpdateMessage> (UI线程安全通信)
                            ↕
┌─────────────────────────────────────────────────────────────────┐
│                       核心服务层                                 │
│                                                                  │
│  CacheManagerService                  FileSyncService           │
│  ├─ 初始化加速 (4步流程)              ├─ FileSystemWatcher      │
│  ├─ 暂停/恢复/停止                    ├─ ConcurrentQueue       │
│  ├─ 状态恢复                          ├─ SemaphoreSlim(3)      │
│  └─ 事件通知                          ├─ 3个Timer循环          │
│                                       └─ 500ms去重窗口          │
│                                                                  │
│  JunctionService        ConfigService       ErrorRecoveryService│
│  ├─ CreateJunction      ├─ JSON持久化       ├─ 状态追踪         │
│  ├─ RemoveJunction      ├─ 自动加载/保存    ├─ 错误记录         │
│  ├─ IsJunction          └─ AppConfig        └─ 自动恢复         │
│  └─ GetTarget                                                   │
│                                                                  │
│  FastCopyService (Singleton)    AsyncLogger (Singleton)         │
│  ├─ 进程执行                    ├─ Channel<LogEntry>            │
│  ├─ 30分钟超时                  ├─ 后台写入                     │
│  └─ 进程监控定时器              └─ 滚动日志(50MB×5)             │
│                                                                  │
│  SafeFileOperations              SingleInstanceManager          │
│  ├─ 文件锁检测                   ├─ Mutex检测                   │
│  ├─ 重试机制                     └─ NamedPipe通信               │
│  └─ 指数退避                                                    │
└─────────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────────┐
│                    外部工具层                                    │
│                                                                  │
│  Robocopy.exe                   FastCopy.exe                    │
│  ├─ 初始批量复制                ├─ 增量文件同步                  │
│  ├─ 64线程                      ├─ 高速传输                     │
│  ├─ 无缓冲I/O                   └─ /auto_close参数              │
│  └─ 3600次重试                                                  │
│                                                                  │
│  Win32 API                                                      │
│  ├─ CreateFile (文件锁检测)                                     │
│  ├─ GetFileAttributes (Junction检测)                            │
│  └─ MessageBoxW (消息框)                                        │
└─────────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────────┐
│                  Windows文件系统层                               │
│                                                                  │
│  NTFS目录连接点 (mklink /J)                                      │
│  ├─ D:\SlowDisk\Folder  →  S:\Cache\D\SlowDisk\Folder          │
│  ├─ D:\SlowDisk\Folder.original (备份原始目录)                   │
│  └─ 无需管理员权限                                               │
│                                                                  │
│  FileSystemWatcher                                              │
│  ├─ 监控: FileName, Size, LastWrite                            │
│  ├─ 事件: Created, Changed, Deleted, Renamed                   │
│  └─ IncludeSubdirectories = true                               │
└─────────────────────────────────────────────────────────────────┘
```

### 架构特点

1. **分层清晰**: UI层、服务层、工具层、系统层职责明确
2. **松耦合**: 通过事件和Channel通信，组件间依赖低
3. **高内聚**: 每个服务单一职责，功能集中
4. **可测试**: 服务层独立于UI，易于单元测试

---

## 2.1.1 数据流向

### 加速初始化流程

```
用户点击"添加文件夹"
    ↓
FolderBrowserDialog选择源目录
    ↓
InputDialog输入缓存根路径
    ↓
CacheManagerService.InitializeCacheAcceleration()
    ↓
┌─────────────────────────────────┐
│ 步骤1: Robocopy批量复制          │
│   源目录 → 缓存目录              │
│   64线程并行                     │
│   无缓冲I/O模式                  │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 步骤2: 重命名原始目录            │
│   D:\MyProject                   │
│     → D:\MyProject.original      │
│   设置隐藏属性                   │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 步骤3: 创建Junction              │
│   mklink /J                      │
│   D:\MyProject                   │
│     → S:\Cache\D\MyProject       │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 步骤4: 启动文件监控              │
│   FileSyncService                │
│   .StartMonitoring()             │
└─────────────────────────────────┘
    ↓
FileSystemWatcher开始监控缓存目录
    ↓
UI显示"已加速"状态
```

### 文件同步流程

```
用户修改缓存中的文件
(实际访问D:\MyProject，重定向到S:\Cache\D\MyProject)
    ↓
FileSystemWatcher.Changed事件触发
    ↓
FileSyncService.OnFileChanged()
    ↓
┌──────────────────────────────────────┐
│ 500ms去重窗口检查                    │
│ ConcurrentDictionary<path, lastTime> │
│ 如果500ms内重复事件 → 忽略           │
└──────────────────────────────────────┘
    ↓
创建SyncOperation对象
    ↓
加入ConcurrentQueue<SyncOperation>
    ↓
ProcessQueueAsync()
(由3个Timer之一触发: 10s智能/30s定期/3s统计)
    ↓
┌──────────────────────────────────────┐
│ SemaphoreSlim.WaitAsync()            │
│ 限制并发FastCopy进程 = 3             │
└──────────────────────────────────────┘
    ↓
┌──────────────────────────────────────┐
│ SafeFileOperations.IsFileInUse()     │
│ 检查文件是否被锁定                   │
│ 如果被锁 → 跳过，下次再试            │
└──────────────────────────────────────┘
    ↓
FastCopyService.CopyFileAsync()
(缓存 → .original目录)
    ↓
执行FastCopy.exe进程
    ↓
等待完成 (最多30分钟超时)
    ↓
┌──────────────────────────────────────┐
│ 通过Channel发送UIUpdateMessage       │
│ FileSyncService → MainWindow         │
└──────────────────────────────────────┘
    ↓
UI更新队列状态
(进行中 → 已完成 / 失败)
```

---

## 2.2 核心组件详解

系统共包含**9个核心服务组件**，每个组件职责单一，协同工作。

---

## 2.2.1 CacheManagerService

**文件位置**: `CacheMax.GUI/Services/CacheManagerService.cs`

### 职责

协调整个加速生命周期，是加速操作的**总控制器**。负责初始化、暂停、恢复、停止加速，以及应用重启后的状态恢复。

### 核心方法

| 方法 | 参数 | 返回 | 说明 |
|------|------|------|------|
| `InitializeCacheAcceleration` | folder, cacheRoot | Task | 执行4步加速流程 |
| `PauseCacheAcceleration` | mountPoint | Task | 暂停监控但保留Junction |
| `ResumeCacheAcceleration` | mountPoint | Task | 恢复监控 |
| `StopCacheAcceleration` | mountPoint, deleteCache | Task | 完全停止并可选删除缓存 |
| `RestoreAccelerationStates` | - | Task | 应用启动时恢复之前的加速状态 |

### 4步加速流程

```csharp
public async Task InitializeCacheAcceleration(string folder, string cacheRoot)
{
    // 步骤1: 批量复制 (Robocopy 64线程)
    await RobocopyHelper.CopyDirectoryAsync(source, cache);

    // 步骤2: 重命名原始目录 .original后缀
    Directory.Move(folder, folder + ".original");
    File.SetAttributes(folder + ".original", FileAttributes.Hidden);

    // 步骤3: 创建Junction
    await JunctionService.CreateDirectoryJunction(folder, cachePath);

    // 步骤4: 启动监控
    await FileSyncService.StartMonitoring(cachePath, folder + ".original");
}
```

### 状态管理

```
未加速 → 初始化中 → 同步中 → 已加速
                ↓
              失败 / 监控失败 / 目录丢失
```

### 事件发布

- `AccelerationStarted`: 加速开始
- `AccelerationCompleted`: 加速完成
- `AccelerationFailed`: 加速失败
- `StatusChanged`: 状态变化（更新UI进度条）

---

## 2.2.2 FileSyncService

**文件位置**: `CacheMax.GUI/Services/FileSyncService.cs`

### 职责

监控缓存目录的文件变化，并**自动同步回**原始`.original`目录。这是实现"双向同步"的核心组件。

### 核心组件

| 组件 | 类型 | 说明 |
|------|------|------|
| `FileSystemWatcher` | .NET内置 | 监控缓存目录的所有文件事件 |
| `_syncQueue` | ConcurrentQueue | 待处理的同步操作队列 |
| `_semaphore` | SemaphoreSlim | 限制并发FastCopy进程（默认3个） |
| `_lastEventTime` | ConcurrentDictionary | 去重窗口（500ms） |
| `_queueItems` | Dictionary | UI队列项映射 |

### 监控机制

```csharp
FileSystemWatcher配置:
- Path: 缓存目录路径
- NotifyFilter: FileName, DirectoryName, Size, LastWrite, CreationTime
- IncludeSubdirectories: true
- 事件订阅:
  * Created → OnFileChanged
  * Changed → OnFileChanged
  * Deleted → OnFileChanged
  * Renamed → OnFileRenamed
```

### 去重算法

```csharp
// 500ms内的重复事件被合并
private readonly ConcurrentDictionary<string, DateTime> _lastEventTime = new();

void OnFileChanged(object sender, FileSystemEventArgs e)
{
    if (_lastEventTime.TryGetValue(e.FullPath, out var lastTime))
    {
        if ((DateTime.Now - lastTime).TotalMilliseconds < 500)
            return; // 忽略重复事件
    }

    _lastEventTime[e.FullPath] = DateTime.Now;
    EnqueueSyncOperation(e.FullPath);
}
```

### 3个Timer循环

```csharp
// Timer 1: 定期同步 (30秒间隔)
_periodicSyncTimer = new Timer(30000);
_periodicSyncTimer.Elapsed += async (s, e) => await ProcessQueueAsync();

// Timer 2: 智能同步 (10秒间隔)
_intelligentSyncTimer = new Timer(10000);
_intelligentSyncTimer.Elapsed += async (s, e) => await AnalyzeAndSync();

// Timer 3: 统计更新 (3秒间隔)
_statsTimer = new Timer(3000);
_statsTimer.Elapsed += (s, e) => UpdateStatistics();
```

### 同步处理流程

```csharp
async Task ProcessQueueAsync()
{
    while (_syncQueue.TryDequeue(out var operation))
    {
        await _semaphore.WaitAsync(); // 限制并发

        try
        {
            if (SafeFileOperations.IsFileInUse(operation.Source))
                continue; // 跳过被锁定的文件

            await FastCopyService.Instance.CopyFileAsync(
                operation.Source,
                operation.Destination
            );

            // 通过Channel更新UI
            await _uiChannel.Writer.WriteAsync(new UIUpdateMessage
            {
                Type = UIUpdateType.QueueItemUpdated,
                Item = operation
            });

            OnSyncCompleted(operation);
        }
        finally
        {
            _semaphore.Release();
        }
    }
}
```

### 事件发布

- `QueueItemAdded`: 新文件加入队列
- `QueueItemUpdated`: 队列项状态更新
- `QueueItemRemoved`: 队列项完成移除
- `SyncStatsUpdated`: 统计信息更新
- `SyncFailed`: 同步失败

---

## 2.2.3 JunctionService

**文件位置**: `CacheMax.GUI/Services/JunctionService.cs`

### 职责

封装Windows目录连接点（Directory Junction）的创建、删除和查询操作。提供简单的API隐藏底层cmd命令细节。

### 核心方法

```csharp
// 创建Junction
public async Task<(bool success, string error)> CreateDirectoryJunction(
    string junctionPath,
    string targetPath)
{
    // 命令: cmd /c mklink /J "{junctionPath}" "{targetPath}"
    var process = new Process
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = "cmd.exe",
            Arguments = $"/c mklink /J \"{junctionPath}\" \"{targetPath}\"",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        }
    };

    process.Start();
    await process.WaitForExitAsync();

    return (process.ExitCode == 0, process.StandardError.ReadToEnd());
}

// 删除Junction
public async Task<(bool success, string error)> RemoveJunction(
    string junctionPath)
{
    // 命令: cmd /c rmdir "{junctionPath}"
    // 注意: 只删除连接点，不删除目标内容
}

// 检测是否为Junction
public bool IsJunction(string path)
{
    var attributes = File.GetAttributes(path);
    return (attributes & FileAttributes.ReparsePoint) == FileAttributes.ReparsePoint;
}

// 获取Junction目标路径
public string GetJunctionTarget(string junctionPath)
{
    // 方法1: fsutil reparsepoint query "{junctionPath}"
    // 方法2: dir /al "{parent}" (作为备用)
}
```

### Junction vs 符号链接

| 特性 | Junction (目录连接点) | SymbolicLink (符号链接) |
|------|----------------------|------------------------|
| **需要管理员** | ❌ 否 | ✅ 是 (或开发者模式) |
| **目标类型** | 仅目录 | 文件+目录 |
| **跨驱动器** | ✅ 支持 | ✅ 支持 |
| **文件系统** | NTFS | NTFS/ReFS |
| **创建命令** | `mklink /J` | `mklink /D` |

### 优势

- **无需管理员权限**: 普通用户即可创建
- **跨驱动器**: 可以从C:\链接到S:\
- **Windows原生**: NTFS文件系统原生支持，稳定可靠
- **透明访问**: 应用程序完全无感知

---

## 2.2.4 FastCopyService

**文件位置**: `CacheMax.GUI/Services/FastCopyService.cs`

### 职责

管理FastCopy.exe进程的执行，提供**超时保护**和**进程监控**，防止卡死进程占用资源。

### 设计模式

**Singleton单例模式** - 全局唯一实例

```csharp
public class FastCopyService
{
    public static FastCopyService Instance { get; } = new FastCopyService();
    private FastCopyService() { }
}
```

### 核心方法

```csharp
public async Task<(bool success, string output)> CopyFileAsync(
    string source,
    string dest,
    CancellationToken cancellationToken = default)
{
    // 1. 检查FastCopy.exe路径
    if (!File.Exists(_fastCopyPath))
        return (false, "FastCopy.exe not found");

    // 2. 构建命令行
    var arguments = $"/cmd=diff /auto_close /force_close \"{source}\" /to=\"{dest}\"";

    // 3. 启动进程
    var process = Process.Start(new ProcessStartInfo
    {
        FileName = _fastCopyPath,
        Arguments = arguments,
        CreateNoWindow = true,
        UseShellExecute = false
    });

    // 4. 等待完成 (最多30分钟超时)
    var completed = await process.WaitForExitAsync(
        TimeSpan.FromMinutes(30),
        cancellationToken
    );

    if (!completed)
    {
        process.Kill(); // 超时强制终止
        return (false, "Timeout after 30 minutes");
    }

    return (process.ExitCode == 0, "Success");
}
```

### 进程监控

```csharp
// 每30秒检查一次所有运行中的FastCopy进程
private Timer _monitorTimer = new Timer(30000);

void MonitorTimerElapsed(object sender, ElapsedEventArgs e)
{
    foreach (var (process, startTime) in _runningProcesses.ToList())
    {
        // 超过30分钟的进程自动Kill
        if ((DateTime.Now - startTime).TotalMinutes > 30)
        {
            process.Kill();
            _runningProcesses.Remove(process);
            AsyncLogger.Instance.Log(
                LogLevel.Warning,
                $"Killed FastCopy process (timeout): {process.Id}"
            );
        }
    }
}
```

### 配置

```json
// appsettings.json
{
  "FastCopy": {
    "ExecutablePath": "C:\\Program Files\\FastCopy64\\fcp.exe",
    "DefaultArguments": "/cmd=diff /auto_close /force_close",
    "MaxConcurrency": 3,
    "TimeoutMinutes": 30
  }
}
```

---

## 2.2.5 ErrorRecoveryService

**文件位置**: `CacheMax.GUI/Services/ErrorRecoveryService.cs`

### 职责

跟踪错误历史，实施**自动恢复策略**。记录每个加速文件夹的状态和错误，根据严重性选择恢复方案。

### 核心数据结构

```csharp
public class AccelerationState
{
    public string MountPoint { get; set; }
    public string OriginalPath { get; set; }
    public string CachePath { get; set; }
    public string Status { get; set; }
    public string LastError { get; set; }
    public int ErrorCount { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? LastAttempt { get; set; }
    public RecoveryStrategy Strategy { get; set; }
}
```

### 错误严重性分级

```csharp
public enum ErrorSeverity
{
    Low,      // 单个文件同步失败，不影响整体
    Medium,   // 多个文件失败，需要关注
    High,     // Junction状态异常，影响访问
    Critical  // 目录丢失或不可访问，严重故障
}
```

### 恢复策略

```csharp
public enum RecoveryStrategy
{
    None,     // 不自动恢复，仅记录错误
    Retry,    // 重试失败的操作
    Reset,    // 重置状态，清除错误计数
    Recreate, // 重建Junction
    Fallback  // 回退到原始目录（删除Junction）
}
```

### 自动恢复机制

```csharp
public async Task TriggerRecovery(string mountPoint)
{
    var state = GetAccelerationState(mountPoint);

    // 根据ErrorSeverity选择RecoveryStrategy
    var strategy = state.Severity switch
    {
        ErrorSeverity.Low => RecoveryStrategy.None,
        ErrorSeverity.Medium => RecoveryStrategy.Retry,
        ErrorSeverity.High => RecoveryStrategy.Recreate,
        ErrorSeverity.Critical => RecoveryStrategy.Fallback,
        _ => RecoveryStrategy.None
    };

    await ExecuteRecovery(state, strategy);
    OnRecoveryAttempted(state);
}
```

### 健康检查

```csharp
public HealthCheckResult PerformHealthCheck(string mountPoint)
{
    var result = new HealthCheckResult { MountPoint = mountPoint };

    // 检查1: Junction存在性
    if (!JunctionService.IsJunction(mountPoint))
        result.AddIssue("Junction丢失");

    // 检查2: Junction目标有效性
    var target = JunctionService.GetJunctionTarget(mountPoint);
    if (target != state.CachePath)
        result.AddIssue("Junction目标异常");

    // 检查3: 缓存目录存在性
    if (!Directory.Exists(state.CachePath))
        result.AddIssue("缓存目录丢失");

    // 检查4: 原始目录存在性
    if (!Directory.Exists(state.OriginalPath))
        result.AddIssue("原始目录丢失");

    // 检查5: 监控状态
    if (!FileSyncService.IsMonitoring(mountPoint))
        result.AddIssue("监控未启动");

    return result;
}
```

---

## 2.2.6 ConfigService

**文件位置**: `CacheMax.GUI/Services/ConfigService.cs`

### 职责

管理应用配置的**加载、保存和持久化**。提供JSON格式的配置存储，支持人工编辑。

### 存储位置

```
{ExecutableDirectory}\accelerated_folders.json
```

### 配置模型

```csharp
public class AppConfig
{
    public string DefaultCacheRoot { get; set; } = "S:\\Cache";
    public List<AcceleratedFolder> AcceleratedFolders { get; set; } = new();
    public bool AutoStartWithWindows { get; set; } = false;
    public bool MinimizeToTray { get; set; } = false;
}

public class AcceleratedFolder
{
    public string OriginalPath { get; set; }
    public string CachePath { get; set; }
    public string MountPoint { get; set; }
    public DateTime CreatedAt { get; set; }
    public string Status { get; set; }
    public int ProgressPercentage { get; set; }
    public long CacheSize { get; set; }
}
```

### 核心方法

```csharp
// 加载配置
public AppConfig LoadConfig()
{
    if (!File.Exists(_configPath))
        return new AppConfig();

    var json = File.ReadAllText(_configPath);
    return JsonConvert.DeserializeObject<AppConfig>(json);
}

// 保存配置
public void SaveConfig(AppConfig config)
{
    var json = JsonConvert.SerializeObject(config, Formatting.Indented);

    // 原子写入（先写临时文件，再替换）
    var tempPath = _configPath + ".tmp";
    File.WriteAllText(tempPath, json);
    File.Move(tempPath, _configPath, overwrite: true);
}

// 查询特定文件夹
public AcceleratedFolder GetAcceleratedFolder(string mountPoint)
{
    var config = LoadConfig();
    return config.AcceleratedFolders
        .FirstOrDefault(f => f.MountPoint == mountPoint);
}

// 添加加速文件夹
public void AddAcceleratedFolder(AcceleratedFolder folder)
{
    var config = LoadConfig();
    config.AcceleratedFolders.Add(folder);
    SaveConfig(config);
}

// 移除加速文件夹
public void RemoveAcceleratedFolder(string mountPoint)
{
    var config = LoadConfig();
    config.AcceleratedFolders.RemoveAll(f => f.MountPoint == mountPoint);
    SaveConfig(config);
}
```

### 配置示例

```json
{
  "DefaultCacheRoot": "S:\\Cache",
  "AcceleratedFolders": [
    {
      "OriginalPath": "D:\\MyProject",
      "CachePath": "S:\\Cache\\D\\MyProject",
      "MountPoint": "D:\\MyProject",
      "CreatedAt": "2025-11-08T10:30:00",
      "Status": "已加速",
      "ProgressPercentage": 100,
      "CacheSize": 1073741824
    }
  ],
  "AutoStartWithWindows": false,
  "MinimizeToTray": true
}
```

---

## 2.2.7 AsyncLogger

**文件位置**: `CacheMax.GUI/Services/AsyncLogger.cs`

### 职责

提供**完全非阻塞**的异步日志记录。使用Channel作为缓冲区，主线程零等待，后台线程处理I/O。

### 设计模式

**Singleton + Producer-Consumer Pattern**

```csharp
public class AsyncLogger
{
    public static AsyncLogger Instance { get; } = new AsyncLogger();

    private readonly Channel<LogEntry> _logChannel;
    private readonly Task _writerTask;

    private AsyncLogger()
    {
        _logChannel = Channel.CreateUnbounded<LogEntry>();
        _writerTask = Task.Run(ProcessLogEntriesAsync);
    }
}
```

### 日志级别

```csharp
public enum LogLevel
{
    Info,
    Warning,
    Error,
    Debug,
    Performance
}
```

### 核心机制

```csharp
// 写入日志 (非阻塞)
public void Log(LogLevel level, string message, Exception exception = null)
{
    var entry = new LogEntry
    {
        Level = level,
        Message = message,
        Exception = exception,
        Timestamp = DateTime.Now,
        ThreadId = Environment.CurrentManagedThreadId
    };

    // 写入Channel (非阻塞，如果满了会丢弃)
    _logChannel.Writer.TryWrite(entry);
}

// 后台处理 (单独线程)
private async Task ProcessLogEntriesAsync()
{
    await foreach (var entry in _logChannel.Reader.ReadAllAsync())
    {
        try
        {
            await WriteToFileAsync(entry);
        }
        catch
        {
            // 日志写入失败，静默处理
        }
    }
}

// 写入文件 (带滚动)
private async Task WriteToFileAsync(LogEntry entry)
{
    var logFile = GetCurrentLogFile();

    // 检查文件大小，超过50MB则滚动
    if (new FileInfo(logFile).Length > 50 * 1024 * 1024)
    {
        RotateLogFiles();
        logFile = GetCurrentLogFile();
    }

    var line = FormatLogEntry(entry);
    await File.AppendAllTextAsync(logFile, line + "\n");
}

// 滚动日志 (最多保留5个文件)
private void RotateLogFiles()
{
    var logFiles = Directory.GetFiles(_logDirectory, "CacheMax_*.log")
        .OrderBy(f => File.GetCreationTime(f))
        .ToList();

    // 删除最旧的文件
    while (logFiles.Count >= 5)
    {
        File.Delete(logFiles[0]);
        logFiles.RemoveAt(0);
    }
}
```

### 滚动日志配置

```csharp
- 目录: {ExecutableDir}\Logs\
- 文件名格式: CacheMax_{timestamp}.log
- 单文件最大: 50MB
- 最多保留: 5个文件
- 总占用空间: ≤ 250MB
```

### 日志格式

```
[2025-11-08 14:30:15.123] [INFO] [Thread:12] Application started
[2025-11-08 14:30:20.456] [WARNING] [Thread:5] File locked: C:\test.txt
[2025-11-08 14:30:25.789] [ERROR] [Thread:8] FastCopy failed: timeout
    at CacheMax.Services.FastCopyService.CopyFileAsync()
    at ...
```

---

## 2.2.8 SafeFileOperations

**文件位置**: `CacheMax.GUI/Services/SafeFileOperations.cs`

### 职责

提供**文件锁检测**和**智能重试**机制。在文件被其他程序占用时，实施指数退避重试策略。

### 核心方法

```csharp
// 检测文件是否被占用
public static bool IsFileInUse(string filePath)
{
    try
    {
        using var handle = CreateFile(
            filePath,
            GENERIC_READ | GENERIC_WRITE,  // 访问模式
            0,                              // 共享模式: 独占
            IntPtr.Zero,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            IntPtr.Zero
        );

        return handle.IsInvalid; // 如果无效句柄，说明被锁定
    }
    catch (Win32Exception ex)
    {
        // ERROR_SHARING_VIOLATION = 32
        return ex.NativeErrorCode == 32;
    }
}

// 检测文件写入是否完成
public static bool IsFileWriteComplete(string filePath, int checksCount = 3)
{
    long previousSize = -1;

    for (int i = 0; i < checksCount; i++)
    {
        var currentSize = new FileInfo(filePath).Length;

        if (currentSize == previousSize)
            return true; // 大小稳定，写入完成

        previousSize = currentSize;
        Thread.Sleep(100); // 等待100ms
    }

    return false; // 大小仍在变化，写入未完成
}

// 获取只读锁
public static FileStream AcquireReadOnlyLock(string filePath)
{
    return new FileStream(
        filePath,
        FileMode.Open,
        FileAccess.Read,
        FileShare.Read
    );
}
```

### 重试策略

```csharp
// 指数退避算法
public static async Task<T> RetryAsync<T>(
    Func<Task<T>> operation,
    int maxRetries = 5)
{
    for (int attempt = 0; attempt <= maxRetries; attempt++)
    {
        try
        {
            return await operation();
        }
        catch (IOException) when (attempt < maxRetries)
        {
            // 等待时间: 100ms, 200ms, 400ms, 800ms, 1600ms
            var delay = (int)Math.Pow(2, attempt) * 100;
            await Task.Delay(delay);
        }
    }

    throw new IOException("Operation failed after retries");
}
```

### 文件锁检测原理

```csharp
[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
static extern SafeFileHandle CreateFile(
    string lpFileName,
    uint dwDesiredAccess,      // GENERIC_READ | GENERIC_WRITE
    uint dwShareMode,          // 0 = 独占访问
    IntPtr lpSecurityAttributes,
    uint dwCreationDisposition,
    uint dwFlagsAndAttributes,
    IntPtr hTemplateFile
);

// 如果文件被其他程序锁定，CreateFile会失败
// 错误码: ERROR_SHARING_VIOLATION (32)
```

---

## 2.2.9 SingleInstanceManager

**文件位置**: `CacheMax.GUI/Services/SingleInstanceManager.cs`

### 职责

确保应用程序**只运行一个实例**（Release模式）。使用Mutex检测实例，NamedPipe实现进程间通信。

### 实现机制

```csharp
public class SingleInstanceManager
{
    private readonly Mutex _mutex;
    private readonly NamedPipeServerStream _pipeServer;

    public SingleInstanceManager()
    {
        // 1. 创建全局Mutex
        _mutex = new Mutex(
            initiallyOwned: true,
            name: "Global\\CacheMax_SingleInstance",
            createdNew: out bool createdNew
        );

        if (!createdNew)
        {
            // 已有实例运行
            ActivateExistingInstance();
            Environment.Exit(0);
        }

        // 2. 启动NamedPipeServer监听
        StartListening();
    }

    // 检测是否已有实例
    public bool IsAnotherInstanceRunning()
    {
        return !_mutex.WaitOne(TimeSpan.Zero, false);
    }

    // 激活已运行的实例
    private void ActivateExistingInstance()
    {
        try
        {
            using var client = new NamedPipeClientStream(
                ".",
                "CacheMax_ActivationPipe",
                PipeDirection.Out
            );

            client.Connect(1000); // 1秒超时

            var message = Encoding.UTF8.GetBytes("ACTIVATE");
            client.Write(message, 0, message.Length);
        }
        catch
        {
            // 连接失败，忽略
        }
    }

    // 监听激活请求
    private void StartListening()
    {
        Task.Run(async () =>
        {
            while (true)
            {
                _pipeServer = new NamedPipeServerStream(
                    "CacheMax_ActivationPipe",
                    PipeDirection.In
                );

                await _pipeServer.WaitForConnectionAsync();

                var buffer = new byte[1024];
                var bytesRead = await _pipeServer.ReadAsync(buffer, 0, buffer.Length);
                var message = Encoding.UTF8.GetString(buffer, 0, bytesRead);

                if (message == "ACTIVATE")
                {
                    // 激活主窗口
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        var mainWindow = Application.Current.MainWindow;
                        mainWindow.Show();
                        mainWindow.WindowState = WindowState.Normal;
                        mainWindow.Activate();
                    });
                }

                _pipeServer.Disconnect();
            }
        });
    }
}
```

### Debug vs Release

```csharp
public SingleInstanceManager()
{
#if DEBUG
    // Debug模式: 允许多实例运行（方便调试）
    return;
#else
    // Release模式: 强制单实例
    if (IsAnotherInstanceRunning())
    {
        ActivateExistingInstance();
        Environment.Exit(0);
    }
#endif
}
```

---

## 相关文档

- **[1.项目概述](./1.项目概述.md)** - 了解项目背景和核心价值
- **[4.统一开发流程](./4.统一开发流程.md)** - 了解数据流程和业务逻辑
- **[5.功能模块设计](./5.功能模块设计.md)** - 深入了解各功能模块实现细节

---

**文档结束** | [返回文档目录](./README.md)
