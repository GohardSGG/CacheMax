# 5. 功能模块设计

> **文档版本**: 3.1
> **更新日期**: 2025-11-08
> **文档说明**: 本文档详细描述CacheMax各功能模块的设计和实现细节

---

## 目录

- [5.1 目录连接点技术](#51-目录连接点技术)
- [5.2 文件同步策略](#52-文件同步策略)
- [5.3 文件锁检测与重试](#53-文件锁检测与重试)
- [5.4 错误处理与恢复](#54-错误处理与恢复)
- [5.5 UI设计与实现](#55-ui设计与实现)
- [5.6 性能优化](#56-性能优化)

---

## 5.1 目录连接点技术

### 为什么选择Junction

| 特性 | Directory Junction | Symbolic Link | Hard Link |
|------|-------------------|---------------|-----------|
| 需要管理员 | ❌ 否 | ✅ 是 | ❌ 否 |
| 目标类型 | 仅目录 | 文件+目录 | 仅文件 |
| 跨驱动器 | ✅ 支持 | ✅ 支持 | ❌ 不支持 |
| 透明度 | 完全透明 | 完全透明 | 透明 |

**选择Junction的原因**:
1. ✅ 无需管理员权限
2. ✅ 支持跨驱动器(C:\ → S:\)
3. ✅ Windows NTFS原生支持
4. ✅ 对应用程序完全透明

### 实现方式

#### 创建Junction

```csharp
public async Task<(bool, string)> CreateDirectoryJunction(
    string junctionPath,
    string targetPath)
{
    var psi = new ProcessStartInfo
    {
        FileName = "cmd.exe",
        Arguments = $"/c mklink /J \"{junctionPath}\" \"{targetPath}\"",
        RedirectStandardOutput = true,
        RedirectStandardError = true,
        UseShellExecute = false,
        CreateNoWindow = true
    };

    var process = Process.Start(psi);
    await process.WaitForExitAsync();

    return (process.ExitCode == 0, process.StandardError.ReadToEnd());
}
```

#### 检测Junction

```csharp
public bool IsJunction(string path)
{
    var attrs = File.GetAttributes(path);
    return (attrs & FileAttributes.ReparsePoint) == FileAttributes.ReparsePoint;
}
```

#### 获取目标路径

```csharp
public string GetJunctionTarget(string junctionPath)
{
    // 方法1: 使用fsutil
    var psi = new ProcessStartInfo
    {
        FileName = "fsutil",
        Arguments = $"reparsepoint query \"{junctionPath}\"",
        RedirectStandardOutput = true
    };

    var process = Process.Start(psi);
    var output = process.StandardOutput.ReadToEnd();

    // 解析输出获取目标路径
    var match = Regex.Match(output, @"Print Name:\s+(.+)");
    return match.Success ? match.Groups[1].Value.Trim() : null;
}
```

### 生命周期管理

```
创建阶段:
  Robocopy复制文件 → 重命名原始 → 创建Junction → 启动监控

使用阶段:
  应用访问Junction → 实际读写缓存 → 后台同步到.original

停止阶段:
  停止监控 → 删除Junction → 可选删除缓存 → 恢复.original名称

恢复阶段:
  读取配置 → 检查Junction → 重启监控
```

---

## 5.2 文件同步策略

### 3个Timer循环

#### 1. 定期同步Timer (30秒)

```csharp
// 处理队列中所有待同步操作
private readonly Timer _periodicSyncTimer = new(30000);

_periodicSyncTimer.Elapsed += async (s, e) =>
{
    if (_syncQueue.Count > 0)
        await ProcessQueueAsync();
};
```

**适用场景**: 批量文件变化，减少频繁I/O

#### 2. 智能同步Timer (10秒)

```csharp
// 分析文件访问模式，优先处理频繁文件
private readonly Timer _intelligentSyncTimer = new(10000);

_intelligentSyncTimer.Elapsed += async (s, e) =>
{
    var frequentFiles = _operationAnalyzer.GetFrequentlyAccessedFiles();
    foreach (var file in frequentFiles)
        await ProcessFileAsync(file);
};
```

**适用场景**: 识别"热"文件，优先同步

#### 3. 统计更新Timer (3秒)

```csharp
// 更新UI统计信息
private readonly Timer _statsTimer = new(3000);

_statsTimer.Elapsed += (s, e) =>
{
    var stats = new SyncStatsEventArgs
    {
        QueueCount = _syncQueue.Count,
        CompletedOperations = _completedCount,
        FailedOperations = _failedCount
    };
    SyncStatsUpdated?.Invoke(this, stats);
};
```

### 去重机制

```csharp
// 500ms去重窗口
private readonly ConcurrentDictionary<string, DateTime> _lastEventTime = new();

void OnFileChanged(object sender, FileSystemEventArgs e)
{
    var now = DateTime.Now;

    if (_lastEventTime.TryGetValue(e.FullPath, out var lastTime))
    {
        // 500ms内的重复事件被忽略
        if ((now - lastTime).TotalMilliseconds < 500)
            return;
    }

    _lastEventTime[e.FullPath] = now;
    EnqueueSyncOperation(e.FullPath);
}
```

---

## 5.3 文件锁检测与重试

### 锁检测实现

```csharp
[DllImport("kernel32.dll", SetLastError = true)]
static extern SafeFileHandle CreateFile(
    string lpFileName,
    uint dwDesiredAccess,
    uint dwShareMode,
    IntPtr lpSecurityAttributes,
    uint dwCreationDisposition,
    uint dwFlagsAndAttributes,
    IntPtr hTemplateFile
);

public static bool IsFileInUse(string filePath)
{
    try
    {
        var handle = CreateFile(
            filePath,
            0x80000000 | 0x40000000, // GENERIC_READ | GENERIC_WRITE
            0,                        // 独占访问
            IntPtr.Zero,
            3,                        // OPEN_EXISTING
            0x80,                     // FILE_ATTRIBUTE_NORMAL
            IntPtr.Zero
        );

        if (handle.IsInvalid)
            return true; // 文件被锁定

        handle.Close();
        return false;
    }
    catch
    {
        return true;
    }
}
```

### 指数退避重试

```csharp
public static async Task<T> RetryWithBackoff<T>(
    Func<Task<T>> operation,
    int maxRetries = 5)
{
    for (int i = 0; i <= maxRetries; i++)
    {
        try
        {
            return await operation();
        }
        catch (IOException) when (i < maxRetries)
        {
            var delay = (int)Math.Pow(2, i) * 100; // 100, 200, 400, 800, 1600ms
            await Task.Delay(delay);
        }
    }

    throw new IOException("Operation failed after all retries");
}
```

### 文件稳定性检查

```csharp
public static bool IsFileWriteComplete(string filePath)
{
    long previousSize = -1;

    for (int i = 0; i < 3; i++)
    {
        var info = new FileInfo(filePath);
        if (info.Length == previousSize)
            return true; // 大小稳定

        previousSize = info.Length;
        Thread.Sleep(100);
    }

    return false; // 仍在写入
}
```

---

## 5.4 错误处理与恢复

### 错误分级

```csharp
public enum ErrorSeverity
{
    Low,      // 单文件失败
    Medium,   // 多文件失败
    High,     // Junction异常
    Critical  // 目录丢失
}
```

### 自动恢复策略

```csharp
public async Task TriggerRecovery(string mountPoint)
{
    var state = GetState(mountPoint);

    var strategy = state.Severity switch
    {
        ErrorSeverity.Low => RecoveryStrategy.None,
        ErrorSeverity.Medium => RecoveryStrategy.Retry,
        ErrorSeverity.High => RecoveryStrategy.Recreate,
        ErrorSeverity.Critical => RecoveryStrategy.Fallback,
        _ => RecoveryStrategy.None
    };

    await ExecuteRecovery(state, strategy);
}
```

### 健康检查

```csharp
public HealthCheckResult PerformHealthCheck(string mountPoint)
{
    var result = new HealthCheckResult();

    // 1. Junction存在?
    if (!JunctionService.IsJunction(mountPoint))
        result.AddIssue("Junction丢失");

    // 2. Junction目标正确?
    var target = JunctionService.GetJunctionTarget(mountPoint);
    if (target != state.CachePath)
        result.AddIssue("Junction目标异常");

    // 3. 目录存在?
    if (!Directory.Exists(state.CachePath))
        result.AddIssue("缓存目录丢失");

    if (!Directory.Exists(state.OriginalPath))
        result.AddIssue("原始目录丢失");

    // 4. 监控运行?
    if (!FileSyncService.IsMonitoring(mountPoint))
        result.AddIssue("监控未启动");

    return result;
}
```

---

## 5.5 UI设计与实现

### MainWindow布局

```xaml
<DockPanel>
    <!-- 工具栏 -->
    <StackPanel DockPanel.Dock="Top">
        <Button Content="添加文件夹" Click="AddFolder_Click"/>
        <Button Content="停止加速" Click="StopAcceleration_Click"/>
    </StackPanel>

    <!-- 加速文件夹列表 -->
    <DataGrid ItemsSource="{Binding AcceleratedFolders}">
        <DataGrid.Columns>
            <DataGridTextColumn Header="原始路径" Binding="{Binding OriginalPath}"/>
            <DataGridTextColumn Header="状态" Binding="{Binding Status}">
                <DataGridTextColumn.ElementStyle>
                    <Style TargetType="TextBlock">
                        <Style.Triggers>
                            <DataTrigger Binding="{Binding Status}" Value="已加速">
                                <Setter Property="Foreground" Value="Green"/>
                            </DataTrigger>
                            <DataTrigger Binding="{Binding Status}" Value="失败">
                                <Setter Property="Foreground" Value="Red"/>
                            </DataTrigger>
                        </Style.Triggers>
                    </Style>
                </DataGridTextColumn.ElementStyle>
            </DataGridTextColumn>
        </DataGrid.Columns>
    </DataGrid>

    <!-- 同步队列 -->
    <TabControl>
        <TabItem Header="进行中">
            <DataGrid ItemsSource="{Binding InProgressQueue}"/>
        </TabItem>
        <TabItem Header="已完成">
            <DataGrid ItemsSource="{Binding CompletedQueue}"/>
        </TabItem>
    </TabControl>

    <!-- 日志输出 -->
    <TextBox x:Name="OutputLog" IsReadOnly="True"
             VerticalScrollBarVisibility="Auto"/>

    <!-- 状态栏 -->
    <StatusBar DockPanel.Dock="Bottom">
        <TextBlock Text="{Binding QueueCount, StringFormat='队列: {0}个'}"/>
        <TextBlock Text="{Binding CompletedCount, StringFormat='成功: {0}个'}"/>
        <TextBlock Text="{Binding FailedCount, StringFormat='失败: {0}个'}"/>
    </StatusBar>
</DockPanel>
```

### Channel驱动更新

```csharp
private readonly Channel<UIUpdateMessage> _uiChannel =
    Channel.CreateUnbounded<UIUpdateMessage>();

// 后台服务发送消息
await _uiChannel.Writer.WriteAsync(new UIUpdateMessage
{
    Type = UIUpdateType.QueueItemAdded,
    Item = newItem
});

// UI线程处理消息
private async Task ProcessUIUpdatesAsync()
{
    await foreach (var msg in _uiChannel.Reader.ReadAllAsync())
    {
        Dispatcher.Invoke(() =>
        {
            switch (msg.Type)
            {
                case UIUpdateType.QueueItemAdded:
                    InProgressQueue.Add(msg.Item);
                    break;
                case UIUpdateType.QueueItemCompleted:
                    InProgressQueue.Remove(msg.Item);
                    CompletedQueue.Add(msg.Item);
                    break;
            }
        });
    }
}
```

---

## 5.6 性能优化

### 并发控制

```csharp
private readonly SemaphoreSlim _semaphore = new(3); // 最多3个并发

await _semaphore.WaitAsync();
try
{
    await FastCopyService.Instance.CopyFileAsync(source, dest);
}
finally
{
    _semaphore.Release();
}
```

### 内存管理

```csharp
// 循环缓冲区,防止无限增长
private readonly CircularBuffer<FileOperation> _recentOperations = new(1000);
private readonly CircularBuffer<TimeSpan> _processingTimes = new(100);

// 日志输出限制
if (OutputLog.LineCount > 150)
{
    var lines = OutputLog.Text.Split('\n');
    OutputLog.Text = string.Join("\n", lines.Skip(lines.Length - 150));
}
```

### 进程超时保护

```csharp
// FastCopy超时机制
var cts = new CancellationTokenSource(TimeSpan.FromMinutes(30));

try
{
    await process.WaitForExitAsync(cts.Token);
}
catch (OperationCanceledException)
{
    process.Kill();
    throw new TimeoutException("FastCopy timeout after 30 minutes");
}
```

### 缓存大小更新优化

#### 问题背景

实时计算目录大小需要递归遍历所有文件，会导致：
1. **频繁磁盘I/O**: 每次文件变化都计算，影响性能
2. **CPU占用高**: 大目录遍历消耗CPU资源
3. **UI卡顿**: 同步计算会阻塞UI线程

**解决方案**: 实现智能更新策略，平衡实时性和性能

#### 三重更新策略

##### 1. 防抖机制（8秒）

**原理**: 文件变化后等待一段时间，如果期间无新变化才更新

```csharp
public void NotifyFileChange()
{
    var now = DateTime.Now;

    // 重置防抖计时器
    _debounceTimer?.Dispose();
    _debounceTimer = new Timer(DebounceCallback, null, 8000, Timeout.Infinite);

    _lastTriggerTime = now;
}

private void DebounceCallback(object? state)
{
    TriggerUpdate("防抖更新（8秒无新变化）");
}
```

**适用场景**:
- 用户正在编辑多个文件
- 编辑器自动保存触发多次变化
- 避免短时间内频繁更新

##### 2. 强制更新机制（45秒）

**原理**: 即使文件持续变化，也强制至少每45秒更新一次

```csharp
public void NotifyFileChange()
{
    var now = DateTime.Now;
    var timeSinceLastTrigger = (now - _lastTriggerTime).TotalMilliseconds;

    // 超过45秒则强制更新
    if (timeSinceLastTrigger >= 45000)
    {
        TriggerUpdate("强制更新（持续变化超过45秒）");
        return;
    }

    // 否则重置防抖计时器
    _debounceTimer?.Dispose();
    _debounceTimer = new Timer(DebounceCallback, null, 8000, Timeout.Infinite);
}
```

**适用场景**:
- 大量文件持续复制/下载
- 编译/构建过程持续写入
- 确保用户能看到进度

##### 3. 定时更新机制（45秒）

**原理**: 无论是否有文件变化，每45秒主动检查一次

```csharp
// 定时器初始化
_periodicTimer = new Timer(
    _ => UpdateNow("定时更新"),
    null,
    45000,  // 延迟45秒启动
    45000   // 每45秒触发一次
);
```

**适用场景**:
- 无文件变化时保持数据新鲜
- 发现外部程序的文件变化（FileSystemWatcher可能遗漏）
- 用户长时间未操作时的后台更新

#### 实现细节

##### 初始更新延迟

```csharp
// 延迟2秒后触发首次更新（等待UI加载完成）
_ = Task.Run(async () => {
    await Task.Delay(2000);
    updater.UpdateNow("延迟初始更新");
});
```

**原因**: 避免时序问题
- UI控件可能尚未绑定
- ObservableCollection可能未初始化
- 过早更新会导致事件丢失

##### 大小写不敏感路径匹配

```csharp
// 错误示例（大小写敏感）
var existingItem = _acceleratedFolders.FirstOrDefault(f =>
    f.CachePath == e.CachePath);  // ❌ 可能匹配失败

// 正确示例（大小写不敏感）
var existingItem = _acceleratedFolders.FirstOrDefault(f =>
    string.Equals(f.CachePath, e.CachePath, StringComparison.OrdinalIgnoreCase));  // ✅
```

**原因**: Windows路径不区分大小写
- `S:\Cache\D\MyProject` 等同于 `s:\cache\d\myproject`
- FileSystemWatcher可能返回不同大小写的路径

##### 事件链路

```
文件变化
    ↓
FileSyncService.OnSyncCompleted
    ↓
CacheManagerService.NotifyCacheFileChange
    ↓
CacheSizeUpdater.NotifyFileChange
    ↓
TriggerUpdate → CalculateDirectorySize
    ↓
onSizeUpdated回调
    ↓
CacheManagerService.StatsUpdated事件
    ↓
MainWindow.OnCacheStatsUpdated
    ↓
UI更新
```

#### 性能对比

| 策略 | 更新频率 | CPU占用 | 实时性 |
|------|---------|---------|--------|
| 实时更新 | 每次变化 | 高 | 最高 |
| 纯定时更新 | 固定间隔 | 低 | 低 |
| **三重策略** | 智能触发 | 低 | 高 |

#### WPF数据绑定要求

**关键教训**: 所有绑定到UI的属性必须实现PropertyChanged通知

```csharp
// ❌ 错误：简单自动属性 - UI不更新
public long CacheSize { get; set; }

// ✅ 正确：带通知的属性 - UI自动更新
private long _cacheSize = 0;
public long CacheSize
{
    get => _cacheSize;
    set
    {
        _cacheSize = value;
        OnPropertyChanged(nameof(CacheSize));
        OnPropertyChanged(nameof(CacheSizeFormatted));  // 同时通知依赖属性
    }
}
```

**同样适用于**:
- `OriginalPath` - 源路径列
- `CachePath` - 缓存路径列
- `Status` - 状态列
- `ProgressPercentage` - 进度条

---

## 相关文档

- **[2.技术架构总览](./2.技术架构总览.md)** - 了解整体架构
- **[4.统一开发流程](./4.统一开发流程.md)** - 了解开发工作流
- **[7.技术风险与解决方案](./7.技术风险与解决方案.md)** - 故障排查

---

**文档结束** | [返回文档目录](./README.md)
